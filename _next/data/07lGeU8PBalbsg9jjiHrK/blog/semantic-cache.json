{"pageProps":{"postMetadata":{"title":"Semantic Cache: Supercharging Agentic AI with Distributed Semantic Search","description":"A deep dive into building a distributed semantic cache using Apache Arrow Flight, HNSW indexing, and consistent hashing - enabling AI agents to retrieve information by meaning, not just exact keys.","imgName":"semantic-cache/semantic-cache.jpeg","date":"Jan 14, 2025","tags":["AI","Semantic Search","Distributed Systems","Agentic AI","Apache Arrow","Vector Database"],"keywords":["semantic cache","agentic AI","distributed systems","vector search","HNSW","Apache Arrow","Arrow Flight","consistent hashing"],"id":"semantic-cache"},"postContent":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    em: \"em\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h4: \"h4\",\n    h6: \"h6\",\n    hr: \"hr\",\n    img: \"img\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    table: \"table\",\n    tbody: \"tbody\",\n    td: \"td\",\n    th: \"th\",\n    thead: \"thead\",\n    tr: \"tr\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"semantic-cache/semantic-cache.jpeg\",\n        alt: \"\\\"Semantic Cache Architecture\\\"\"\n      })\n    }), \"\\n\", _jsxs(_components.h6, {\n      id: \"published-on-jan-14-2025\",\n      children: [\"Published on: \", _jsx(_components.strong, {\n        children: \"Jan 14, 2025\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"semantic-cache-supercharging-agentic-ai-with-distributed-semantic-search\",\n      children: \"Semantic Cache: Supercharging Agentic AI with Distributed Semantic Search\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"i-introduction\",\n      children: \"I. Introduction\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Traditional caching systems require exact key matches to retrieve data. But what if you could find cached information by \", _jsx(_components.em, {\n        children: \"meaning\"\n      }), \" instead? This is the core idea behind \", _jsx(_components.strong, {\n        children: \"Semantic Cache\"\n      }), \" - a distributed key-value store I built that combines the speed of traditional caching with the intelligence of semantic search.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the world of agentic AI, where autonomous agents need to reason, remember, and act without constant human guidance, semantic caching becomes a game-changer. Instead of agents repeating expensive computations or API calls for semantically similar queries, they can retrieve relevant past results instantly.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"ii-the-problem-with-traditional-caching\",\n      children: \"II. The Problem with Traditional Caching\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Traditional caching systems like Redis or Memcached are incredibly fast, but they have a fundamental limitation: \", _jsx(_components.strong, {\n        children: \"they only work with exact key matches\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Consider this scenario in an agentic AI system:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Agent caches a response\\ncache.set(\\\"How to optimize database queries?\\\", response_1)\\n\\n# Later, a semantically similar question comes in\\ncache.get(\\\"database query optimization techniques\\\")  # Returns None!\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The second query is semantically identical to the first, but traditional caches miss this connection entirely. The agent must recompute or re-fetch the answer, wasting time and resources.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Semantic Cache solves this\"\n      }), \" by indexing data with vector embeddings and enabling similarity-based retrieval:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Store with semantic indexing\\nsemantic_kv.put(\\\"optimize-db-001\\\", {\\n    \\\"query\\\": \\\"How to optimize database queries?\\\",\\n    \\\"response\\\": \\\"Use indexing, query optimization, caching...\\\"\\n})\\n\\n# Search by meaning - finds the relevant cached response!\\nresults = semantic_kv.search(\\\"database query optimization techniques\\\", top_k=3)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"iii-technology-stack\",\n      children: \"III. Technology Stack\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"apache-arrow-the-foundation\",\n      children: \"Apache Arrow: The Foundation\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Apache Arrow\"\n      }), \" is a cross-language development platform for in-memory columnar data. The semantic cache uses Arrow in two critical ways:\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"1-arrow-ipc-for-persistence\",\n      children: \"1. Arrow IPC for Persistence\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The persistence layer uses Arrow's IPC (Inter-Process Communication) format to serialize KV entries to disk. The schema is defined as:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"KV_SCHEMA = pa.schema([\\n    ('key', pa.string()),\\n    ('value', pa.large_binary()),\\n    ('embedding', pa.list_(pa.float32())),\\n    ('created_at', pa.int64()),\\n    ('ttl_ms', pa.int64()),\\n    ('access_count', pa.int64()),\\n    ('last_accessed', pa.int64()),\\n])\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This columnar format provides:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Efficient compression\"\n        }), \": Similar data types stored together compress better\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Fast partial reads\"\n        }), \": Can read only specific columns without loading entire records\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Zero-copy deserialization\"\n        }), \": Data can be memory-mapped directly without parsing\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Cross-language compatibility\"\n        }), \": Arrow files can be read by Python, C++, Java, Rust, etc.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"2-arrow-flight-for-network-communication\",\n      children: \"2. Arrow Flight for Network Communication\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Arrow Flight\"\n      }), \" is a high-performance RPC framework built on gRPC and Arrow. Each node in the cluster is a Flight server that handles operations via the \", _jsx(_components.code, {\n        children: \"do_action\"\n      }), \" protocol:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"class SemanticKVNode(flight.FlightServerBase):\\n    def do_action(self, context, action):\\n        action_type = action.type\\n        body = action.body.to_pybytes()\\n\\n        if action_type == \\\"put\\\":\\n            return self._action_put(body)\\n        elif action_type == \\\"get\\\":\\n            return self._action_get(body)\\n        elif action_type == \\\"search_local\\\":\\n            return self._action_search_local(body)\\n        # ... other actions\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Available Flight actions:\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Action\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"put\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Store key-value pair with embedding\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"put_replica\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Store replica (internal, from other nodes)\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"get\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Exact key lookup with TTL check\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"search_local\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Semantic search on local HNSW index\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"delete\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Remove key from store and index\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"scan\"\n            })\n          }), _jsx(_components.td, {\n            children: \"List keys by prefix\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"stats\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Return node statistics\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"health\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Health check\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"clear\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Clear all data\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Why Arrow Flight over plain gRPC?\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Native columnar data\"\n        }), \": Perfect for batch operations and large result sets\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Zero-copy semantics\"\n        }), \": Data moves directly from network buffer to application\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Built-in streaming\"\n        }), \": Efficient for large result sets without loading all into memory\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Standard protocol\"\n        }), \": Interoperable with Arrow ecosystem (Spark, Pandas, DuckDB)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"iv-in-memory-storage-architecture\",\n      children: \"IV. In-Memory Storage Architecture\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"primary-storage-python-dictionary\",\n      children: \"Primary Storage: Python Dictionary\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The cache operates as an \", _jsx(_components.strong, {\n        children: \"in-memory first\"\n      }), \" system. Each node maintains data in a Python dictionary with \", _jsx(_components.code, {\n        children: \"KVEntry\"\n      }), \" dataclass objects:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"@dataclass\\nclass KVEntry:\\n    key: str\\n    value: bytes\\n    embedding: np.ndarray      # Vector embedding (384-3072 dims)\\n    created_at: int            # Timestamp (milliseconds)\\n    ttl_ms: int                # Time-to-live (0 = no expiration)\\n    access_count: int = 0      # Access statistics\\n    last_accessed: int = 0     # Last access timestamp\\n\\n# Storage structure\\nself._store: Dict[str, KVEntry] = {}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"thread-safety\",\n      children: \"Thread Safety\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All operations are protected by a reentrant lock (\", _jsx(_components.code, {\n        children: \"threading.RLock\"\n      }), \"):\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"def _action_get(self, body: bytes):\\n    key = body.decode()\\n\\n    with self._lock:  # Thread-safe access\\n        if key not in self._store:\\n            return [flight.Result(b\\\"\\\")]\\n\\n        entry = self._store[key]\\n\\n        # Check expiration\\n        if self._is_expired(entry):\\n            self._delete_entry(key)\\n            return [flight.Result(b\\\"\\\")]\\n\\n        # Update access stats\\n        entry.access_count += 1\\n        entry.last_accessed = int(time.time() * 1000)\\n\\n        return [flight.Result(entry.value)]\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"ttl-expiration\",\n      children: \"TTL Expiration\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Entries support time-to-live with lazy expiration checking:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"def _is_expired(self, entry: KVEntry) -> bool:\\n    if entry.ttl_ms <= 0:\\n        return False  # No expiration\\n    now_ms = int(time.time() * 1000)\\n    return (now_ms - entry.created_at) > entry.ttl_ms\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"v-persistence-layer\",\n      children: \"V. Persistence Layer\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While the primary storage is in-memory, the system provides durable persistence through the \", _jsx(_components.code, {\n        children: \"ArrowKVStore\"\n      }), \" class:\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"saving-data\",\n      children: \"Saving Data\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"class ArrowKVStore:\\n    def save(self, entries: Dict[str, KVEntry], index=None, metadata=None):\\n        # Convert entries to Arrow table\\n        keys, values, embeddings = [], [], []\\n        for key, entry in entries.items():\\n            keys.append(key)\\n            values.append(entry.value)\\n            embeddings.append(entry.embedding.tolist())\\n\\n        table = pa.Table.from_arrays([\\n            pa.array(keys),\\n            pa.array(values, type=pa.large_binary()),\\n            pa.array(embeddings, type=pa.list_(pa.float32())),\\n            # ... other columns\\n        ], schema=KV_SCHEMA)\\n\\n        # Write to Arrow IPC file\\n        with pa.OSFile(str(self._data_file), 'wb') as sink:\\n            writer = ipc.new_file(sink, table.schema)\\n            writer.write_table(table)\\n            writer.close()\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"loading-data\",\n      children: \"Loading Data\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"def load(self) -> Tuple[List[PersistedEntry], Dict]:\\n    # Memory-map the Arrow file for zero-copy reads\\n    with pa.memory_map(str(self._data_file), 'r') as source:\\n        reader = ipc.open_file(source)\\n        table = reader.read_all()\\n\\n    entries = []\\n    for i in range(table.num_rows):\\n        entry = PersistedEntry(\\n            key=table['key'][i].as_py(),\\n            value=table['value'][i].as_py(),\\n            embedding=np.array(table['embedding'][i].as_py()),\\n            # ... other fields\\n        )\\n        entries.append(entry)\\n\\n    return entries, metadata\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"hnsw-index-persistence\",\n      children: \"HNSW Index Persistence\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The HNSW index is persisted separately using hnswlib's native format:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Saving\\nindex.save_index(str(self._index_file))\\n\\n# Loading\\nindex = hnswlib.Index(space='cosine', dim=dim)\\nindex.load_index(str(self._index_file))\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"snapshot-manager\",\n      children: \"Snapshot Manager\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For backup and recovery, the \", _jsx(_components.code, {\n        children: \"SnapshotManager\"\n      }), \" provides:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"class SnapshotManager:\\n    def create_snapshot(self, name: str = None):\\n        # Copy all data files to snapshot directory\\n        shutil.copytree(\\n            self._data_dir,\\n            snapshot_dir,\\n            ignore=shutil.ignore_patterns('snapshots')\\n        )\\n\\n    def restore_snapshot(self, name: str):\\n        # Remove current data, copy snapshot back\\n        ...\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"vi-cluster-formation-and-topology\",\n      children: \"VI. Cluster Formation and Topology\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"static-node-configuration\",\n      children: \"Static Node Configuration\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The cluster uses a \", _jsx(_components.strong, {\n        children: \"static configuration\"\n      }), \" model where nodes are known at startup:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Client connects to pre-configured nodes\\nclient = DistributedSemanticKV([\\n    \\\"grpc://node1:8815\\\",\\n    \\\"grpc://node2:8816\\\",\\n    \\\"grpc://node3:8817\\\",\\n    \\\"grpc://node4:8818\\\",\\n])\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Each node is an independent Flight server:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Start individual nodes\\nnode1 = SemanticKVNode(\\n    location=\\\"grpc://0.0.0.0:8815\\\",\\n    node_id=\\\"node-1\\\",\\n    embedding_provider=SentenceTransformerEmbedding(),\\n)\\nnode1.serve()  # Blocks, runs gRPC server\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"connection-pooling\",\n      children: \"Connection Pooling\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The client maintains a \", _jsx(_components.strong, {\n        children: \"lazy connection pool\"\n      }), \" with thread-safe initialization:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"def _get_client(self, node: str) -> flight.FlightClient:\\n    with self._clients_lock:\\n        if node not in self._clients:\\n            self._clients[node] = flight.FlightClient(node)\\n        return self._clients[node]\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"retry-logic-with-backoff\",\n      children: \"Retry Logic with Backoff\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Failed operations are retried with exponential backoff:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"def _execute_with_retry(self, node, action_type, body, retries=2):\\n    for attempt in range(retries + 1):\\n        try:\\n            client = self._get_client(node)\\n            action = flight.Action(action_type, body)\\n            results = list(client.do_action(action))\\n            return results[0].body.to_pybytes()\\n        except Exception:\\n            # Remove stale connection, backoff, retry\\n            del self._clients[node]\\n            time.sleep(0.1 * (attempt + 1))\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"vii-query-distribution-consistent-hashing\",\n      children: \"VII. Query Distribution: Consistent Hashing\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"how-consistent-hashing-works\",\n      children: \"How Consistent Hashing Works\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The system uses \", _jsx(_components.strong, {\n        children: \"consistent hashing with virtual nodes\"\n      }), \" to distribute keys across the cluster. The implementation uses MD5 hashing:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"class ConsistentHashRing:\\n    def __init__(self, nodes: List[str], virtual_nodes: int = 150):\\n        self._virtual_nodes = virtual_nodes\\n        self._ring: List[Tuple[int, str]] = []\\n\\n        for node in nodes:\\n            self.add_node(node)\\n\\n    def _hash(self, key: str) -> int:\\n        return int(hashlib.md5(key.encode()).hexdigest(), 16)\\n\\n    def add_node(self, node: str):\\n        # Add virtual nodes for even distribution\\n        for i in range(self._virtual_nodes):\\n            virtual_key = f\\\"{node}:vnode:{i}\\\"\\n            hash_val = self._hash(virtual_key)\\n            self._ring.append((hash_val, node))\\n\\n        # Sort for binary search\\n        self._ring.sort(key=lambda x: x[0])\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"virtual-nodes-for-even-distribution\",\n      children: \"Virtual Nodes for Even Distribution\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With 150 virtual nodes per physical node:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Even key distribution\"\n        }), \": Keys spread uniformly across nodes\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Minimal reshuffling\"\n        }), \": Adding/removing a node only remaps ~1/N keys\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"O(log n) lookups\"\n        }), \": Binary search on sorted ring\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"def get_node(self, key: str) -> str:\\n    hash_val = self._hash(key)\\n\\n    # Binary search for first node with hash >= key hash\\n    idx = bisect_right(self._hash_values, hash_val)\\n\\n    # Wrap around if past the end\\n    if idx >= len(self._ring):\\n        idx = 0\\n\\n    return self._ring[idx][1]\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"operation-routing-patterns\",\n      children: \"Operation Routing Patterns\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Different operations use different routing strategies:\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Operation\"\n          }), _jsx(_components.th, {\n            children: \"Strategy\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"put(key, value)\"\n            })\n          }), _jsx(_components.td, {\n            children: _jsx(_components.strong, {\n              children: \"Deterministic\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Hash key -> single responsible node\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"get(key)\"\n            })\n          }), _jsx(_components.td, {\n            children: _jsx(_components.strong, {\n              children: \"Deterministic\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Hash key -> single responsible node\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"delete(key)\"\n            })\n          }), _jsx(_components.td, {\n            children: _jsx(_components.strong, {\n              children: \"Deterministic\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Hash key -> single responsible node\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"search(query)\"\n            })\n          }), _jsx(_components.td, {\n            children: _jsx(_components.strong, {\n              children: \"Scatter-Gather\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Query ALL nodes -> merge by similarity\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"scan(prefix)\"\n            })\n          }), _jsx(_components.td, {\n            children: _jsx(_components.strong, {\n              children: \"Scatter-Gather\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Query ALL nodes -> deduplicate keys\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"put-deterministic-write\",\n      children: \"PUT: Deterministic Write\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"def put(self, key: str, value: bytes, ttl_ms: int = 0) -> bool:\\n    # Hash determines the single responsible node\\n    node = self._ring.get_node(key)\\n\\n    data = json.dumps({\\n        'key': key,\\n        'value': list(value),\\n        'ttl_ms': ttl_ms\\n    })\\n\\n    result = self._execute_with_retry(node, \\\"put\\\", data.encode())\\n    return result == b\\\"ok\\\"\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"get-deterministic-read\",\n      children: \"GET: Deterministic Read\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"def get(self, key: str) -> Optional[bytes]:\\n    # Same hash -> same node as PUT\\n    node = self._ring.get_node(key)\\n\\n    result = self._execute_with_retry(node, \\\"get\\\", key.encode())\\n    return result if result else None\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"search-scatter-gather\",\n      children: \"SEARCH: Scatter-Gather\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Semantic search \", _jsx(_components.strong, {\n        children: \"must query all nodes\"\n      }), \" because similar items may be distributed anywhere:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"def search(self, query: str, top_k: int = 10, threshold: float = 0.7):\\n    params = json.dumps({\\n        'query': query,\\n        'top_k': top_k,\\n        'threshold': threshold\\n    })\\n\\n    def search_node(node: str) -> List[dict]:\\n        result = self._execute_with_retry(node, \\\"search_local\\\", params.encode())\\n        return json.loads(result.decode()) if result else []\\n\\n    # SCATTER: Query all nodes in parallel\\n    all_nodes = self._ring.get_all_nodes()\\n    futures = {\\n        self._executor.submit(search_node, node): node\\n        for node in all_nodes\\n    }\\n\\n    # GATHER: Collect results with timeout\\n    all_results = []\\n    for future in as_completed(futures, timeout=self._search_timeout):\\n        node_results = future.result()\\n        all_results.extend(node_results)\\n\\n    # MERGE: Sort by similarity, return top-k\\n    all_results.sort(key=lambda x: x['similarity'], reverse=True)\\n    return all_results[:top_k]\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The thread pool uses \", _jsx(_components.code, {\n        children: \"nodes * 2\"\n      }), \" workers by default for parallel operations:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"self._executor = ThreadPoolExecutor(max_workers=len(nodes) * 2)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"viii-vector-indexing-with-hnsw\",\n      children: \"VIII. Vector Indexing with HNSW\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"hnsw-algorithm\",\n      children: \"HNSW Algorithm\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"HNSW (Hierarchical Navigable Small World)\"\n      }), \" is a state-of-the-art algorithm for approximate nearest neighbor search:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"self._index = create_vector_index(\\n    dim=self._embedding_provider.dimension,  # 384-3072\\n    max_elements=max_entries,                 # 100,000 default\\n    ef_construction=200,                      # Build quality\\n    M=16,                                     # Connections per node\\n    ef_search=50                              # Search quality\\n)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"index-operations\",\n      children: \"Index Operations\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Each node maintains its own HNSW index with bidirectional mappings:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Mappings between keys and index positions\\nself._key_to_idx: Dict[str, int] = {}\\nself._idx_to_key: Dict[int, str] = {}\\nself._next_idx = 0\\n\\n# Adding to index during PUT\\nidx = self._next_idx\\nself._index.add_items(embedding.reshape(1, -1), [idx])\\nself._key_to_idx[key] = idx\\nself._idx_to_key[idx] = key\\nself._next_idx += 1\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"local-semantic-search\",\n      children: \"Local Semantic Search\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"def _action_search_local(self, body: bytes):\\n    params = json.loads(body.decode())\\n    query = params['query']\\n    top_k = params.get('top_k', 10)\\n    threshold = params.get('threshold', 0.7)\\n\\n    # Generate query embedding\\n    query_embedding = self._get_embedding(query)\\n\\n    # Search HNSW index\\n    k = min(top_k, self._index.get_current_count())\\n    labels, distances = self._index.knn_query(\\n        query_embedding.reshape(1, -1),\\n        k=k\\n    )\\n\\n    results = []\\n    for label, dist in zip(labels[0], distances[0]):\\n        # Cosine distance to similarity\\n        similarity = 1.0 - dist\\n\\n        if similarity >= threshold:\\n            key = self._idx_to_key[label]\\n            entry = self._store[key]\\n\\n            results.append({\\n                'key': key,\\n                'value': entry.value.decode(),\\n                'similarity': float(similarity),\\n                'node': self.node_id\\n            })\\n\\n    return [flight.Result(json.dumps(results).encode())]\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"ix-embedding-providers\",\n      children: \"IX. Embedding Providers\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Three embedding backends are supported:\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"sentencetransformers-recommended\",\n      children: \"SentenceTransformers (Recommended)\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"from sentence_transformers import SentenceTransformer\\n\\nclass SentenceTransformerEmbedding:\\n    def __init__(self, model_name=\\\"all-MiniLM-L6-v2\\\"):\\n        self.model = SentenceTransformer(model_name)\\n        self.dimension = self.model.get_sentence_embedding_dimension()\\n\\n    def embed(self, text: str) -> np.ndarray:\\n        return self.model.encode(text, convert_to_numpy=True)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"openai-embeddings-premium\",\n      children: \"OpenAI Embeddings (Premium)\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"import openai\\n\\nclass OpenAIEmbedding:\\n    def __init__(self, model=\\\"text-embedding-3-small\\\"):\\n        self.client = openai.OpenAI()\\n        self.model = model\\n\\n    def embed(self, text: str) -> np.ndarray:\\n        response = self.client.embeddings.create(\\n            input=text,\\n            model=self.model\\n        )\\n        return np.array(response.data[0].embedding)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"x-performance-characteristics\",\n      children: \"X. Performance Characteristics\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Benchmarked on a 4-node localhost cluster:\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Operation\"\n          }), _jsx(_components.th, {\n            children: \"Throughput\"\n          }), _jsx(_components.th, {\n            children: \"Avg Latency\"\n          }), _jsx(_components.th, {\n            children: \"P99 Latency\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"GET (hit)\"\n          }), _jsx(_components.td, {\n            children: \"7,195 ops/sec\"\n          }), _jsx(_components.td, {\n            children: \"0.14 ms\"\n          }), _jsx(_components.td, {\n            children: \"0.18 ms\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"GET (miss)\"\n          }), _jsx(_components.td, {\n            children: \"6,288 ops/sec\"\n          }), _jsx(_components.td, {\n            children: \"0.16 ms\"\n          }), _jsx(_components.td, {\n            children: \"0.62 ms\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"PUT (100B)\"\n          }), _jsx(_components.td, {\n            children: \"3,579 ops/sec\"\n          }), _jsx(_components.td, {\n            children: \"0.28 ms\"\n          }), _jsx(_components.td, {\n            children: \"0.43 ms\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"PUT (1KB)\"\n          }), _jsx(_components.td, {\n            children: \"2,721 ops/sec\"\n          }), _jsx(_components.td, {\n            children: \"0.37 ms\"\n          }), _jsx(_components.td, {\n            children: \"0.46 ms\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"DELETE\"\n          }), _jsx(_components.td, {\n            children: \"7,100 ops/sec\"\n          }), _jsx(_components.td, {\n            children: \"0.14 ms\"\n          }), _jsx(_components.td, {\n            children: \"0.20 ms\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"SEARCH (1K keys)\"\n          }), _jsx(_components.td, {\n            children: \"344 ops/sec\"\n          }), _jsx(_components.td, {\n            children: \"2.91 ms\"\n          }), _jsx(_components.td, {\n            children: \"3.37 ms\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"SEARCH (10K keys)\"\n          }), _jsx(_components.td, {\n            children: \"46 ops/sec\"\n          }), _jsx(_components.td, {\n            children: \"21.59 ms\"\n          }), _jsx(_components.td, {\n            children: \"30.48 ms\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"SCAN\"\n          }), _jsx(_components.td, {\n            children: \"1,396 ops/sec\"\n          }), _jsx(_components.td, {\n            children: \"0.72 ms\"\n          }), _jsx(_components.td, {\n            children: \"0.86 ms\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"xi-use-cases-in-agentic-ai\",\n      children: \"XI. Use Cases in Agentic AI\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"1-query-caching-for-agent-memory\",\n      children: \"1. Query Caching for Agent Memory\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Store reasoning with semantic indexing\\nkv.put_json(\\\"reasoning:001\\\", {\\n    \\\"query\\\": \\\"How to handle authentication errors?\\\",\\n    \\\"response\\\": \\\"Check token expiration, refresh if needed...\\\",\\n    \\\"confidence\\\": 0.95\\n})\\n\\n# Later, find relevant past reasoning\\nresults = kv.search(\\\"authentication token expired\\\", top_k=5)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"2-tool-discovery-by-capability\",\n      children: \"2. Tool Discovery by Capability\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Store tool metadata\\nkv.put_json(\\\"tool:sql-executor\\\", {\\n    \\\"name\\\": \\\"SQL Executor\\\",\\n    \\\"description\\\": \\\"Executes parameterized SQL queries\\\"\\n})\\n\\n# Agent searches for relevant tools\\ntools = kv.search(\\\"execute database queries\\\", top_k=3)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"3-multi-agent-knowledge-sharing\",\n      children: \"3. Multi-Agent Knowledge Sharing\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Agent A discovers rate limit\\nagent_a.put_json(\\\"discovery:rate-limit\\\", {\\n    \\\"endpoint\\\": \\\"/api/users\\\",\\n    \\\"limit\\\": \\\"100 req/min\\\"\\n})\\n\\n# Agent B searches without knowing exact key\\nresults = agent_b.search(\\\"API rate limiting\\\", top_k=1)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"4-conversation-context-retrieval\",\n      children: \"4. Conversation Context Retrieval\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Store conversation turns\\nkv.put_json(\\\"conv:turn:42\\\", {\\n    \\\"user\\\": \\\"What files are in the project?\\\",\\n    \\\"assistant\\\": \\\"[directory listing]\\\"\\n})\\n\\n# Retrieve relevant context\\ncontext = kv.search(\\\"explore project structure\\\", top_k=5)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"xii-getting-started\",\n      children: \"XII. Getting Started\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"installation\",\n      children: \"Installation\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"pip install semantic-kv\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"start-a-cluster\",\n      children: \"Start a Cluster\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"from semantic_kv import SemanticKVNode, DistributedSemanticKV\\n\\n# Start nodes (in separate processes)\\nnode1 = SemanticKVNode(location=\\\"grpc://0.0.0.0:8815\\\", node_id=\\\"node-1\\\")\\nnode2 = SemanticKVNode(location=\\\"grpc://0.0.0.0:8816\\\", node_id=\\\"node-2\\\")\\n\\n# Connect client\\nclient = DistributedSemanticKV([\\n    \\\"grpc://localhost:8815\\\",\\n    \\\"grpc://localhost:8816\\\"\\n])\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"basic-operations\",\n      children: \"Basic Operations\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"# Store data\\nclient.put(\\\"key1\\\", b\\\"value1\\\")\\nclient.put_json(\\\"user:123\\\", {\\\"name\\\": \\\"Alice\\\", \\\"role\\\": \\\"admin\\\"})\\n\\n# Exact retrieval\\nvalue = client.get(\\\"key1\\\")\\nuser = client.get_json(\\\"user:123\\\")\\n\\n# Semantic search\\nresults = client.search(\\\"find admin users\\\", top_k=5, threshold=0.7)\\nfor key, value, similarity, node in results:\\n    print(f\\\"Key: {key}, Score: {similarity:.2f}\\\")\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"xiii-conclusion\",\n      children: \"XIII. Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Semantic Cache bridges the gap between traditional caching systems and modern AI requirements. The key architectural decisions:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Apache Arrow Flight\"\n        }), \" for high-performance RPC with zero-copy semantics\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Arrow IPC format\"\n        }), \" for efficient persistence and cross-language compatibility\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"In-memory primary storage\"\n        }), \" with optional disk persistence\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Consistent hashing\"\n        }), \" for deterministic key routing with minimal reshuffling\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Scatter-gather pattern\"\n        }), \" for distributed semantic search\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"HNSW indexing\"\n        }), \" for sub-millisecond vector similarity search\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This combination enables agentic AI systems to:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Find relevant past experiences by meaning\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Avoid redundant computations\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Share knowledge across agents naturally\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Scale horizontally with demand\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Related Reading\"\n      }), \":\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://arrow.apache.org/docs/format/Flight.html\",\n          children: \"Apache Arrow Flight\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://arxiv.org/abs/1603.09320\",\n          children: \"Hierarchical Navigable Small World (HNSW)\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://en.wikipedia.org/wiki/Consistent_hashing\",\n          children: \"Consistent Hashing\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"id":"semantic-cache"},"__N_SSG":true}