{"pageProps":{"postMetadata":{"title":"CDN with On-Demand Image Resizing with Google Cloud","description":" A Cost-Efficient and efficient CDN Approach to serving media content","imgName":"cdn/cdn.jpeg","date":"Apr 11, 2025","tags":["GCP","CDN","Image Processing","Routing","Content Network"],"keywords":["AI","CDN","GLB","CDN","Routing"],"id":"content-network"},"postContent":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    em: \"em\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h6: \"h6\",\n    img: \"img\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"cdn/cdn.jpeg\",\n        alt: \"\\\"CDN with On-Demand Image Resizing on GCP\\\"\"\n      })\n    }), \"\\n\", _jsxs(_components.h6, {\n      id: \"published-on-apr-11-2025\",\n      children: [\"Published on: \", _jsx(_components.strong, {\n        children: \"Apr 11, 2025\"\n      })]\n    }), \"\\n\", _jsx(_components.h1, {\n      id: \"on-demand-image-resizing-with-google-cloud-a-cost-efficient-cdn-approach\",\n      children: \"On-Demand Image Resizing with Google Cloud: A Cost-Efficient CDN Approach\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"introduction\",\n      children: \"Introduction\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We needed to serve images to our frontend application. These images were in a GCS bucket. In addition, we needed to serve images of various resolutions and we didn't want to store all image sizes in the bucket.  We chose to use a combo of CDN and load balancer on GCP to serve these images to the frontend. However, instead of storing all the variants of an image, we chose to generate resized versions on the fly when the frontend requests them--and cache those for performance and cost reasons.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"requirements\",\n      children: \"Requirements:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Dynamically resizes images on demand\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Caches generated sizes efficiently, to reduce compute costs\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Integrates seamlessly with Google Cloud Platform (GCP) services\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"architecture-overview\",\n      children: \"Architecture Overview\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Our final solution combined four key GCP services:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Google Cloud CDN\"\n        }), \": Caches resized images at edge locations\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Global Load Balancer (GLB)\"\n        }), \": Routes requests based on query parameters, between CDN and Cloud Run resizing services\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Cloud Run\"\n        }), \": Stateless container for image processing\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"GCS Bucket\"\n        }), \": Stores original high-resolution images\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"cdn/arch.jpg\",\n        alt: \"\\\"CDN with On-Demand Image Resizing on GCP\\\"\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"implementation-walkthrough\",\n      children: \"Implementation Walkthrough\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"General steps to follow for the implementation\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Deploy a resizing service (Cloud Function/Cloud Run) that takes parameters (e.g., image path, width, height) and returns the resized image.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Configure the Load Balancer's backend service to point to this resizing service, and enable Cloud CDN on it.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Set up the route rules for URL Map structure so that requests for resized images include the parameters, like width and height.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The resizing service fetches the original image from GCS, resizes it, and returns it with appropriate Cache-Control headers so Cloud CDN caches it.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The CDN then serves subsequent requests for the same size from the cache.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"1-dynamic-resizing-service-cloud-run\",\n      children: \"1. Dynamic Resizing Service (Cloud Run)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We chose Cloud Run over Cloud Functions for better control over containerization and longer request timeouts. The service uses Express.js and Sharp - a high-performance Node.js image processing library.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Key features of the resizer:\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-txt\",\n        children: \"const express = require('express'); \\nconst sharp = require('sharp'); \\nconst { Storage } = require('@google-cloud/storage'); \\nconst storage = new Storage(); \\nconst app = express(); \\napp.get('/:filename', async (req, res) => { \\n\\tconst { filename } = req.params; \\n\\tconst width = parseInt(req.query.width) || undefined; \\n\\tconst height = parseInt(req.query.height) || undefined; \\n\\ttry { \\n\\t\\tconst bucket = storage.bucket('sb-listing-data'); \\n\\t\\tconst file = bucket.file(filename); \\n\\t\\tconst [exists] = await file.exists(); \\n\\t\\tif (!exists) return res.status(404).send('Not found'); \\n\\t\\t\\n\\t\\tconst readStream = file.createReadStream(); \\n\\t\\tlet pipeline = sharp();\\n\\t\\tif (width > 2048 || height > 2048) {\\n\\t\\t     return res.status(400).send('Maximum size 2048px');\\n\\t\\t} \\n\\t\\tif (width && height) { \\n\\t\\t\\tpipeline = pipeline.resize(width, height, { fit: 'inside' }); \\n\\t\\t} \\n\\t\\tres.set('Cache-Control', 'public, max-age=2629800'); // Cache for 1 month \\n\\t\\tres.setHeader(\\\"content-type\\\", \\\"image/jpeg\\\");\\n\\t\\treadStream.pipe(pipeline).pipe(res); \\n\\t} catch (error) { \\n\\t\\tres.status(500).send('Error processing image'); \\n\\t} \\n}); \\nexports.resizer=app;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Critical caching headers ensure proper CDN behavior:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-txt\",\n        children: \"res.set('Cache-Control', 'public, max-age=2629800'); // 1 month\\nres.set('Content-Type', 'image/jpeg');\\nres.set('Vary', 'Accept, Width, Height'); // Prevent parameter collisions\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"2-intelligent-routing-with-global-load-balancer\",\n      children: \"2. Intelligent Routing with Global Load Balancer\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The GLB's URL Map routes requests based on query parameters:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-txt\",\n        children: \"defaultService: projects/xyz/global/backendBuckets/cdn-fe \\nname: url-map-query-params \\nrouteRules: \\n- matchRules: \\n\\t- queryParameterMatches: \\n\\t\\t- name: width \\n\\t\\t  presentMatch: true \\n\\t\\t- name: height \\n\\t\\t  presentMatch: true \\n\\t\\tpathTemplateMatch: /{filename=*} \\n\\tpriority: 1 \\n\\tservice: projects//global/backendServices/resizer\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Routing Logic:\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"| Request Type               | Example URL                            | Destination       |\\n|---------------------------|----------------------------------------|-------------------|\\n| With width & height params | \", _jsx(_components.code, {\n        children: \"/images/cat.jpg?width=300&height=200\"\n      }), \" | Cloud Run Resizer |\\n| All other requests         | \", _jsx(_components.code, {\n        children: \"/images/cat.jpg\"\n      }), \"                      | GCS Bucket        |\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"some-other-considerations\",\n      children: \"Some other considerations\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"The resizing service should handle errors, like invalid sizes or missing images. Also, using a CDN requires setting proper cache headers. The service should return \", _jsx(_components.em, {\n          children: \"Cache-Control: public, max-age=...\"\n        }), \" so the CDN caches it.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Security\"\n        }), \": Ensure that the service can't be abused to generate too many sizes, possibly adding rate limiting or size restrictions.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Cost\"\n        }), \": Processing images on demand with Cloud Run/Cloud Functions incur costs based on the number of requests and processing time. Caching with CDN reduces the number of times the backend is hit and avoids saving different images sizes.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Cache Invalidation\"\n        }), \": Implement versioned URLs (\", _jsx(_components.em, {\n          children: \"/v2/images/...\"\n        }), \") to force CDN refresh when updating resizing logic.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Error Handling\"\n        }), \": Custom error pages prevent CDN caching of error states:\", \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"hljs language-txt\",\n            children: \".on('error', (err) => {\\n  res.status(500).sendFile('error500.jpg');\\n});\\n\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Monitoring\"\n        }), \": Critical Cloud Monitoring metrics:\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"CDN Cache Hit Ratio\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Resizer 5xx Errors\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Backend Latency Percentiles\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Alternative Image Protocols\"\n        }), \", this example is limited to jpeg.\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"WebP/AVIF format support\"\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Density-aware \", _jsx(_components.em, {\n              children: \"srcset\"\n            }), \" generation\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Auto-Cropping/watermark-removal/blurring etc\"\n        }), \", consider other applications using Cloud Vision API\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"conclusion\",\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This architecture reduced our image storage costs by 70% while maintaining sub-200ms response times for cached assets.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"id":"content-network"},"__N_SSG":true}